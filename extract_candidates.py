import csv

# This function will be used primarily to
# retrieve the calculated GC content from the separate
# file generated by the gc_calc above.
# Probably need to find a better way of doing this but it will suffice
def gc_calc_lookup(gc_file, header):

    # Header doesn't have the >
    string = ">"
    string += header
    
    # Create input file stream
    infile = open(gc_file, "r", 1)

    # Match to keep track when seq is found
    match = 0
    # Read through each to find header
    for line in infile:
        
        # Make sure that you don't grab endline character
        line = line[:-1]

        # Match was found so the next line (this one) has the GC
        if match == 1:
            return line

        # Check if the header matches the line in gc file, set to found
        if string == line:
            match = 1

# Need to only keep the output sequences that have an E value greater
# than 0.1. This makes the e_val variable though.
# Will also only keep the query id (1st column), subject id (2nd column),
# e value (11th column), bit score (12th column)
#
# The last part of the function will create a file with sequences that
# did not appear in the blast output, and will also output their GC contents.
def extract_candidates(filename, e_val, gc_file):

    # Create filename for output file, configured with
    # _candidates suffix.
    output_filename = ""
    for c in filename:
        if c == ".":
            output_filename += "_candidates"
            output_filename += str(e_val)
        output_filename += c

    # Create the output filestream
    output = open(output_filename, "w", 1)

    # Create a set to hold the unique headers from blast output
    aligned = set()

    # Read from the csv file
    with open(filename, newline='') as csvfile:

        # Specifiy delimiter
        spamreader = csv.reader(csvfile, delimiter='\t', )

        # Iterate through each entry from blast output
        for row in spamreader:

            aligned.add(row[0])
            # Only interested in a certain e_val range
            if (float((row[10])) >= e_val):

                # Writes query id
                output.write(row[0])
                output.write('\t')

                # Writes subject id
                output.write(row[1])
                output.write('\t')

                # Writes e_value
                output.write(row[10])
                output.write('\t')

                # Writes bit_score
                output.write(row[11])
                output.write('\t')

                # Writes gc content
                gc = gc_calc_lookup(gc_file, row[0])
                output.write(gc)
                output.write('\n')

    # Now the set aligned should have all the headers that aligned in blast run
    infile_gc = open(gc_file, "r", 1)

    # Create output file stream for non-aligned results
    output_gc = open("results_unaligned.txt", "w", 1)

    # Tracker for determining if not found
    tracker = 0
    
    # Iterate/read through GC file
    for line in infile_gc:

        # Make sure endline char is discarded
        line = line[:-1]

        # Make string without the > char
        string = line[1:]

        # Check if tracker set to 1
        if tracker == 1:
            output_gc.write(string)
            output_gc.write('\n')
            tracker = 0
            
        # Ignore the GC contents
        if string[0] == "N":

            if string not in aligned:

                output_gc.write(string)
                output_gc.write('\t')
                tracker = 1
        
    

#extract_candidates

# GC Calculator
# Creates a file containing the header followed by another line with the
# calculated GC content. Need to work on fitting / formatting them together
def gc_calc(fasta):

    # Create input file stream
    infile = open(fasta, "r", 1)

    # Create output file and file name
    output_filename = ""
    for c in fasta:
        if c == ".":
            output_filename += "_gc"
        output_filename += c

    output = open(output_filename, "w", 1)

    # These numbers will keep track of and help calculate GC content
    length = 0
    count = 0

    # Iterate through each line in the fasta file. Assumes headers fixed
    for line in infile:

        # Detects a header
        if line[0] == ">":
            output.write(line)

        # Detects end of sequence
        elif line[0] == "\n":

            if length > 0:
                content = float(count / length)
                output.write(str(content))
                output.write("\n")
            count = 0
            length = 0

        # Detects sequence. Updates count and length accordingly
        else:
            for c in line:
                if c == "G" or c == "C":
                    count += 1
                length += 1

                # Note: this for loop grabs the end line characters,
                # so we need to adjust the length accordingly by
                # subtracting 1
                if c == "\n":
                    length -= 1

##############################################################################

# Main

# Input headerfix fasta file to calculate the GC content.
string2 = input("Select file to calculate GC content: ")
print("Calculating GC content...")
gc_calc(string2)
print("Done! Output file has '_gc' appended before the file type.")

# Input blast output file
string = input("Pick candidates from file: ")
e_val = float(input("Set minimum interested e-value: "))
# Input the gc content file.
gc_lookup = input("Select file for GC content (should be _gc from above!): ")
print("Selecting candidates...")
extract_candidates(string, e_val, gc_lookup)
print("Done!")

